\chapter{Sistemas Operativos}
\section{Introducción a la Programación de Sistemas}
\section{Sistema de Ficheros}
\section{Gestión de Procesos}
\subsection{Señales}
...
\subsubsection{Captura}
Se hace con la llamada a sigaction(señal, acccion, antigua\_accion)
%Explicar como funciona esta funcion
\begin{itemize}
    \item sa\_handler
    \item sa\_mask
    \item sa\_flags
\end{itemize}
- Si hacemos una llamada al sistema dentro del manejador, es necesario restaurar el valor de errno, justo antes de devolver el control al programa principal.
%%Programa sa_handler, que acaba cuando hacemos 5 veces ctrl+C
\begin{lstlisting}[language=C++]
#include <signal.h>
#include <stdlib.h>

volatile int count=0;

void handler(int signal){
    count++;
}

int main(){
    struct sigaction sa;
    int rc;
    
    sa.sa_handler = handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA.RESTART;
    rec = sigaction (SIGINT, &sa, NULL);
    if(rc==-1){
        perror("sigaction");
        exit(1);
        //se puede usar tambien exit(EXIT_FAILURE);
    }
    while(count<5);
}
\end{lstlisting}
\subsubsection{Señales de espera}
La señal sigsuspend.
\subsubsection{Señales de alarma}
La señal alarm
getitimer
setitimer
%Y de aqui pasa directamente a tuberias
\subsection{Tuberías}
Es un canal de comunicacion unidireccional entre procesos. El sistema las trata como si fueran ficheros(nº de inodo, op entrada salida tipicas...). Ademas realiza la sincronizacion necesaria entre los extremos de la tuberia. La tubería reside en memoria principal. Las tuberias es lo que se utiliza para concatenar comandos. Concatena la salida de un comando con la entrada de otro
ls -l | wc -l nos cuenta las lineas que ocupa ls -l

Crear una tuberia

int pipe(int fd[2]);

- Una tuberia se bloquea hasta que esten todos los descriptores de ficheros cerrados.
- Si todos los descriptores de lectura se han cerrado, el proceso q intente escribir se va a llevar la señal SIGPIPE.

- 

* Esquema de comunicacion de tuberias

* Esquema comunicacion bidireccional: es necesario crear dos pipes, no se suele usar, xq se suelen usar sockets

* Esquema los pasos que habria que seguir para comunicar dos procesos

%%%Puede ser que el codigo tenga un error por qu el padre no ha cerrado el descriptor de fichero. probar!!!!!!
\begin{lstlisting}[language=C++]
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(){
    int fd[2], rc, pid;
    
    rc = pipe(fd);
    if(rc==1){
        perror("pipe");
        exit(1);
    }
    
    pid = fork();
    if(pid==-1){
        perror("fork");
        exit(1);
    }else if(pid==0){
        dup2(fd[1],STDUOT_FILEND);
        close(fd[0]);
        close(fd[1]);
        execlp("ls","ls","-l",NULL);
    }
    
    
    pid = fork();
    if(pid==-1){
        perror("fork");
        exit(1);
    }else if(pid==0){
        dup2(fd[1],STDIN_FILEND);
        close(fd[0]);
        close(fd[1]);
        execlp("wc","wc","-l",NULL);
    }
    wait(NULL);//espera al prmer hijo
    wait(NULL);//espera al seg hijo
}

}
\end{lstlisting}
\subsubsection{Tuberías con nombre}
Procesos que estan accediendo al mismo fichero, están accediendo al mismo pipe
\subsection{Sincronización de entrada/salida}
LLamada a select, monitorizar un conjunto de descriptores de ficheros y las señal select se bloquea hasta qu uno de esos descriptores esta listo para ser leido.
Select recibe 3 conjuntos: explicar cabecera.

\section{Programación con Sockets}
















